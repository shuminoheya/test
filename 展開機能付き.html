<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>巨大ファイル復号対応</title>
  <style>
    body { font-family: sans-serif; padding: 2em; background: #f0f4f8; }
    .box { background: white; padding: 20px; border-radius: 8px; max-width: 500px; margin: auto; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
    input, button { margin: 10px 0; width: 100%; padding: 10px; font-size: 1em; }
    progress { width: 100%; height: 20px; }
    #status { margin-top: 10px; color: #333; }
  </style>
</head>
<body>
  <div class="box">
    <h2>復号（100GB対応・チャンク統合）</h2>
    <input type="file" id="fileInput" accept=".shumi">
    <input type="password" id="password" placeholder="パスワードを入力">
    <button id="decryptBtn">復号実行</button>
    <progress id="progressBar" value="0"></progress>
    <div id="status">待機中...</div>
  </div>

  <script>
    document.getElementById('decryptBtn').addEventListener('click', async () => {
      const file = document.getElementById('fileInput').files[0];
      const password = document.getElementById('password').value;
      const status = document.getElementById('status');
      const progressBar = document.getElementById('progressBar');

      if (!file || !password) {
        alert('ファイルとパスワードを入力してください');
        return;
      }

      if (!window.showDirectoryPicker) {
        alert('このブラウザはフォルダ選択に対応していません。');
        return;
      }

      let folderHandle;
      try {
        folderHandle = await window.showDirectoryPicker();
      } catch (err) {
        status.textContent = 'フォルダの選択がキャンセルされました。';
        return;
      }

      const fileName = file.name.endsWith('.shumi') ? file.name.slice(0, -6) : file.name;
      const key = await deriveKey(password);
      const chunkNames = [];
      let offset = 0;
      let chunkIndex = 0;

      progressBar.max = file.size;
      progressBar.value = 0;

      try {
        while (offset + 16 <= file.size) {
          const header = await file.slice(offset, offset + 16).arrayBuffer();
          const view = new DataView(header);
          const encryptedLength = view.getUint32(0, true);
          const iv = new Uint8Array(header.slice(4, 16));

          const encryptedData = await file.slice(offset + 16, offset + 16 + encryptedLength).arrayBuffer();
          const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, encryptedData);

          const chunkName = `chunk_${String(chunkIndex).padStart(6, '0')}.tmp`;
          const chunkHandle = await folderHandle.getFileHandle(chunkName, { create: true });
          const writable = await chunkHandle.createWritable();
          await writable.write(new Uint8Array(decrypted));
          await writable.close();
          chunkNames.push(chunkName);

          offset += 16 + encryptedLength;
          chunkIndex++;
          progressBar.value = offset;
          status.textContent = `復号中: チャンク ${chunkIndex}`;
          await new Promise(requestAnimationFrame);
        }

        // 統合ファイル作成
        try {
          await folderHandle.removeEntry(fileName).catch(() => {});
          const finalHandle = await folderHandle.getFileHandle(fileName, { create: true });
          const finalWritable = await finalHandle.createWritable();

          for (const name of chunkNames) {
            const handle = await folderHandle.getFileHandle(name);
            const file = await handle.getFile();
            const stream = file.stream();
            const reader = stream.getReader();
            while (true) {
              const { done, value } = await reader.read();
              if (done) break;
              await finalWritable.write(value);
            }
          }

          await finalWritable.close();

          // チャンク削除
          for (const name of chunkNames) {
            await folderHandle.removeEntry(name);
          }

          status.textContent = '復号完了！（.shumiに統合）';
          progressBar.value = progressBar.max;
        } catch (mergeErr) {
          console.error('統合エラー:', mergeErr);
          status.textContent = '統合エラー';
        }
      } catch (err) {
        console.error('復号エラー:', err);
        status.textContent = '復号エラー：' + err.message;
      }
    });

    async function deriveKey(password) {
      const enc = new TextEncoder();
      const salt = enc.encode('shumi-salt');
      const keyMaterial = await crypto.subtle.importKey(
        'raw', enc.encode(password), { name: 'PBKDF2' }, false, ['deriveKey']
      );
      return crypto.subtle.deriveKey(
        { name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['decrypt']
      );
    }
  </script>
</body>
</html>
