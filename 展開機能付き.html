<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>復号（直接書き込み）</title>
  <style>
    body { font-family: sans-serif; padding: 2em; background: #f0f4f8; }
    .box { background: white; padding: 20px; border-radius: 8px; max-width: 500px; margin: auto; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
    input, button { margin: 10px 0; width: 100%; padding: 10px; font-size: 1em; }
    progress { width: 100%; height: 20px; }
    #status { margin-top: 10px; color: #333; }
  </style>
</head>
<body>
  <div class="box">
    <h2>復号（.shumi に直接追記）</h2>
    <input type="file" id="fileInput" accept=".shumi">
    <input type="password" id="password" placeholder="パスワードを入力">
    <button id="decryptBtn">復号実行</button>
    <progress id="progressBar" value="0"></progress>
    <div id="status">待機中...</div>
  </div>

  <script>
    document.getElementById('decryptBtn').addEventListener('click', async () => {
      const file = document.getElementById('fileInput').files[0];
      const password = document.getElementById('password').value;
      const status = document.getElementById('status');
      const progressBar = document.getElementById('progressBar');

      if (!file || !password) {
        alert('ファイルとパスワードを入力してください');
        return;
      }

      if (!window.showDirectoryPicker) {
        alert('このブラウザはフォルダ選択に対応していません。');
        return;
      }

      let folderHandle;
      try {
        folderHandle = await window.showDirectoryPicker();
      } catch (err) {
        status.textContent = 'フォルダの選択がキャンセルされました。';
        return;
      }

      const outputName = file.name.endsWith('.shumi') ? file.name.slice(0, -6) : file.name;
      const key = await deriveKey(password);
      let offset = 0;
      let chunkIndex = 0;

      progressBar.max = file.size;
      progressBar.value = 0;

      try {
        // 出力ファイル作成
        try {
          await folderHandle.removeEntry(outputName).catch(() => {});
        } catch (_) {}
        const outputHandle = await folderHandle.getFileHandle(outputName, { create: true });
        const outputStream = await outputHandle.createWritable();

        while (offset + 16 <= file.size) {
          const header = await file.slice(offset, offset + 16).arrayBuffer();
          const view = new DataView(header);
          const encryptedLength = view.getUint32(0, true);
          const iv = new Uint8Array(header.slice(4, 16));

          const encryptedData = await file.slice(offset + 16, offset + 16 + encryptedLength).arrayBuffer();
          const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, encryptedData);

          await outputStream.write(new Uint8Array(decrypted));

          offset += 16 + encryptedLength;
          chunkIndex++;
          progressBar.value = offset;
          status.textContent = `復号中: チャンク ${chunkIndex}`;
          await new Promise(requestAnimationFrame);
        }

        await outputStream.close();
        status.textContent = '復号完了！（.shumiに直接書き込み）';
        progressBar.value = progressBar.max;
      } catch (err) {
        console.error('復号エラー:', err);
        status.textContent = '復号エラー：' + err.message;
      }
    });

    async function deriveKey(password) {
      const enc = new TextEncoder();
      const salt = enc.encode('shumi-salt');
      const keyMaterial = await crypto.subtle.importKey(
        'raw', enc.encode(password), { name: 'PBKDF2' }, false, ['deriveKey']
      );
      return crypto.subtle.deriveKey(
        { name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['decrypt']
      );
    }
  </script>
</body>
</html>
