<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ファイル暗号化・復号化</title>
  <style>
    body { font-family: sans-serif; padding: 2em; background: #f0f4f8; }
    .box { background: white; padding: 20px; border-radius: 8px; max-width: 500px; margin: auto; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
    input, button, select { margin: 10px 0; width: 100%; padding: 10px; font-size: 1em; }
    progress { width: 100%; height: 20px; }
    #status { margin-top: 10px; color: #333; }
  </style>
</head>
<body>
  <div class="box">
    <h2>ファイル暗号化・復号化</h2>
    <select id="mode">
      <option value="encrypt">暗号化（→ .shumi）</option>
      <option value="decrypt">復号化（.shumi → 元ファイル）</option>
    </select>
    <input type="file" id="fileInput">
    <input type="password" id="password" placeholder="パスワードを入力">
    <button id="runBtn">実行</button>
    <progress id="progressBar" value="0"></progress>
    <div id="status">待機中...</div>
  </div>

  <script>
    const CHUNK_SIZE = 15 * 1024 * 1024;

    document.getElementById('runBtn').addEventListener('click', async () => {
      const file = document.getElementById('fileInput').files[0];
      const password = document.getElementById('password').value;
      const mode = document.getElementById('mode').value;
      const status = document.getElementById('status');
      const progressBar = document.getElementById('progressBar');

      if (!file || !password) {
        alert('ファイルとパスワードを入力してください');
        return;
      }

      if (!window.showSaveFilePicker) {
        alert('このブラウザは保存に対応していません。');
        return;
      }

      const key = await deriveKey(password);
      let suggestedName = mode === 'encrypt' ? file.name + '.shumi' : (file.name.endsWith('.shumi') ? file.name.slice(0, -6) : file.name);

      let writableStream;
      try {
        const handle = await window.showSaveFilePicker({
          suggestedName,
          types: [{ description: 'All Files', accept: { '*/*': ['.*'] } }]
        });
        writableStream = await handle.createWritable();
      } catch (e) {
        status.textContent = '保存先の選択がキャンセルされました。';
        return;
      }

      progressBar.max = file.size;
      progressBar.value = 0;

      try {
        if (mode === 'encrypt') {
          let offset = 0;
          let chunkIndex = 0;

          while (offset < file.size) {
            const chunk = await file.slice(offset, offset + CHUNK_SIZE).arrayBuffer();
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const encrypted = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, chunk);
            const encryptedBytes = new Uint8Array(encrypted);
            const lengthBytes = new Uint8Array(4);
            new DataView(lengthBytes.buffer).setUint32(0, encryptedBytes.length, true);

            const combined = new Uint8Array(4 + 12 + encryptedBytes.length);
            combined.set(lengthBytes, 0);
            combined.set(iv, 4);
            combined.set(encryptedBytes, 16);

            await writableStream.write(combined);

            offset += CHUNK_SIZE;
            chunkIndex++;
            progressBar.value = offset;
            status.textContent = `暗号化中: チャンク ${chunkIndex}`;
            await new Promise(requestAnimationFrame);
          }

          await writableStream.close();
          status.textContent = '暗号化完了！（.shumiに保存）';
        } else {
          let offset = 0;
          let chunkIndex = 0;

          while (offset + 16 <= file.size) {
            const header = await file.slice(offset, offset + 16).arrayBuffer();
            const view = new DataView(header);
            const encryptedLength = view.getUint32(0, true);
            const iv = new Uint8Array(header.slice(4, 16));
            const encryptedData = await file.slice(offset + 16, offset + 16 + encryptedLength).arrayBuffer();

            const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, encryptedData);
            await writableStream.write(new Uint8Array(decrypted));

            offset += 16 + encryptedLength;
            chunkIndex++;
            progressBar.value = offset;
            status.textContent = `復号中: チャンク ${chunkIndex}`;
            await new Promise(requestAnimationFrame);
          }

          await writableStream.close();
          status.textContent = '復号完了！（元ファイルに保存）';
        }

        progressBar.value = progressBar.max;
      } catch (err) {
        console.error('処理エラー:', err);
        status.textContent = 'エラー：' + err.message;
      }
    });

    async function deriveKey(password) {
      const enc = new TextEncoder();
      const salt = enc.encode('shumi-salt');
      const keyMaterial = await crypto.subtle.importKey(
        'raw', enc.encode(password), { name: 'PBKDF2' }, false, ['deriveKey']
      );
      return crypto.subtle.deriveKey(
        { name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt', 'decrypt']
      );
    }
  </script>
</body>
</html>
