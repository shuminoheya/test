<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>復号テスト</title>
  <style>
    body { font-family: sans-serif; padding: 2em; background: #f0f4f8; }
    .box { background: white; padding: 20px; border-radius: 8px; max-width: 500px; margin: auto; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
    input, button { margin: 10px 0; width: 100%; padding: 10px; font-size: 1em; }
    progress { width: 100%; height: 20px; }
    #status { margin-top: 10px; color: #333; }
  </style>
</head>
<body>
  <div class="box">
    <h2>復号テスト（ディスク保存専用）</h2>
    <input type="file" id="fileInput" accept=".shumi">
    <input type="password" id="password" placeholder="パスワードを入力">
    <label><input type="checkbox" id="lowMemoryMode" checked disabled> パフォーマンス低下モード（必須）</label>
    <button id="decryptBtn">復号実行</button>
    <progress id="progressBar" value="0" max="100"></progress>
    <div id="status">待機中...</div>
  </div>

  <script>
    const CHUNK_SIZE = 15 * 1024 * 1024;
    let folderHandle = null;

    document.getElementById('decryptBtn').addEventListener('click', async () => {
      const file = document.getElementById('fileInput').files[0];
      const password = document.getElementById('password').value;
      const status = document.getElementById('status');
      const progressBar = document.getElementById('progressBar');

      if (!file || !password) {
        alert('ファイルとパスワードを入力してください');
        return;
      }

      if (!window.showDirectoryPicker) {
        alert('このブラウザはフォルダ選択に対応していません。');
        return;
      }

      try {
        folderHandle = await window.showDirectoryPicker();
      } catch (err) {
        status.textContent = 'フォルダの選択がキャンセルされました。';
        return;
      }

      const fileName = file.name.endsWith('.shumi') ? file.name.slice(0, -6) : file.name;
      const tempName = fileName + '.crswap';

      const key = await deriveKey(password);
      const fileBuffer = await file.arrayBuffer();
      const dataView = new DataView(fileBuffer);
      let offset = 0;
      let chunkIndex = 0;

      try {
        const tempHandle = await folderHandle.getFileHandle(tempName, { create: true });
        const writable = await tempHandle.createWritable();

        while (offset + 16 <= fileBuffer.byteLength) {
          const encryptedLength = dataView.getUint32(offset, true);
          const iv = new Uint8Array(fileBuffer.slice(offset + 4, offset + 16));
          const encryptedData = fileBuffer.slice(offset + 16, offset + 16 + encryptedLength);

          status.textContent = `復号中: チャンク ${++chunkIndex}`;
          progressBar.value = (offset / fileBuffer.byteLength) * 100;

          const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, encryptedData);
          await writable.write(new Uint8Array(decrypted));

          offset += 16 + encryptedLength;
        }

        await writable.close();

        // 上書き防止のため既存ファイル削除
        try {
          await folderHandle.removeEntry(fileName);
        } catch (e) {}

        const finalHandle = await folderHandle.getFileHandle(fileName, { create: true });
        const finalWritable = await finalHandle.createWritable();
        const tempFile = await (await tempHandle.getFile()).arrayBuffer();
        await finalWritable.write(tempFile);
        await finalWritable.close();

        await folderHandle.removeEntry(tempName);

        status.textContent = '復号完了！（ディスク保存）';
        progressBar.value = 100;
      } catch (err) {
        console.error(err);
        status.textContent = '復号エラー：' + err.message;
      }
    });

    async function deriveKey(password) {
      const enc = new TextEncoder();
      const salt = enc.encode('shumi-salt');
      const keyMaterial = await crypto.subtle.importKey(
        'raw', enc.encode(password), { name: 'PBKDF2' }, false, ['deriveKey']
      );
      return crypto.subtle.deriveKey(
        { name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        false,
        ['decrypt']
      );
    }
  </script>
</body>
</html>
