<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼‹QRæ¥ç¶š WebRTC ãƒãƒ£ãƒƒãƒˆ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆ -->
  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
  <!-- ã‚«ãƒ¡ãƒ©ã§QRèª­ã¿å–ã‚Š -->
  <script src="https://unpkg.com/html5-qrcode"></script>
  <style>
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; padding: 16px; }
    h1 { font-size: 1.4rem; }
    input, button { font-family: inherit; font-size: 1rem; }
    #chatLog { border: 1px solid #ccc; height: 200px; overflow-y: auto; padding: 8px; margin-top: 8px; }
    #msg { width: 70%; }
    #qrcodeHost, #qrcodeGuest { margin: 8px 0; }
    .box { border: 1px solid #ddd; padding: 10px; margin-top: 10px; border-radius: 8px; }
    #reader { width: 260px; margin-top: 8px; }
    .role-label { font-weight: 600; }
  </style>
</head>
<body>
  <h1>ğŸ” ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼‹QRæ¥ç¶š WebRTC ãƒãƒ£ãƒƒãƒˆ</h1>

  <div class="box">
    <div>â‘  ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼ˆ2äººã§åŒã˜ã‚‚ã®ã‚’ä½¿ã†ï¼‰</div>
    <input id="password" type="text" placeholder="ä¾‹: secret123">
  </div>

  <div class="box">
    <div>â‘¡ ã©ã¡ã‚‰ã‹ãŒ <span class="role-label">ãƒ›ã‚¹ãƒˆ</span>ã€ã‚‚ã†ä¸€æ–¹ãŒ <span class="role-label">ã‚²ã‚¹ãƒˆ</span> ã‚’é¸ã¶</div>
    <button id="hostBtn">ãƒ›ã‚¹ãƒˆã¨ã—ã¦éƒ¨å±‹ã‚’ä½œã‚‹</button>
    <button id="guestBtn">ã‚²ã‚¹ãƒˆã¨ã—ã¦å‚åŠ ã™ã‚‹</button>
  </div>

  <div class="box">
    <div class="role-label">ãƒ›ã‚¹ãƒˆç”¨ã‚¨ãƒªã‚¢</div>
    <ol>
      <li>ã€Œãƒ›ã‚¹ãƒˆã¨ã—ã¦éƒ¨å±‹ã‚’ä½œã‚‹ã€ã‚’æŠ¼ã™</li>
      <li>å°‘ã—å¾…ã¤ã¨ QR ãŒå‡ºã‚‹ã®ã§ã€ã‚²ã‚¹ãƒˆã«ã‚«ãƒ¡ãƒ©ã§èª­ã¿å–ã£ã¦ã‚‚ã‚‰ã†</li>
      <li>ãã®å¾Œã€ã‚²ã‚¹ãƒˆå´ã«å‡ºãŸ QR ã‚’ã€ŒQRèª­ã¿å–ã‚Šé–‹å§‹ã€ã§èª­ã¿å–ã‚‹</li>
    </ol>
    <div>ã‚²ã‚¹ãƒˆã«èª­ã‚“ã§ã‚‚ã‚‰ã†ãƒ›ã‚¹ãƒˆã® QR:</div>
    <canvas id="qrcodeHost"></canvas>
    <div>ã‚²ã‚¹ãƒˆã‹ã‚‰è¿”ã£ã¦ããŸ QR ã‚’ã‚«ãƒ¡ãƒ©ã§èª­ã¿å–ã‚‹:</div>
    <div id="readerHost"></div>
  </div>

  <div class="box">
    <div class="role-label">ã‚²ã‚¹ãƒˆç”¨ã‚¨ãƒªã‚¢</div>
    <ol>
      <li>ã€Œã‚²ã‚¹ãƒˆã¨ã—ã¦å‚åŠ ã™ã‚‹ã€ã‚’æŠ¼ã™</li>
      <li>ã€ŒQRèª­ã¿å–ã‚Šé–‹å§‹ã€ã‚’æŠ¼ã—ã¦ã€ãƒ›ã‚¹ãƒˆã® QR ã‚’ã‚«ãƒ¡ãƒ©ã§èª­ã‚€</li>
      <li>å°‘ã—å¾…ã¤ã¨è‡ªåˆ†ç”¨ã® QR ãŒå‡ºã‚‹ã®ã§ã€ãã‚Œã‚’ãƒ›ã‚¹ãƒˆã«èª­ã¿å–ã£ã¦ã‚‚ã‚‰ã†</li>
    </ol>
    <button id="startScanGuest">QRèª­ã¿å–ã‚Šé–‹å§‹ï¼ˆãƒ›ã‚¹ãƒˆã®QRï¼‰</button>
    <div id="reader"></div>
    <div>ãƒ›ã‚¹ãƒˆã«èª­ã‚“ã§ã‚‚ã‚‰ã†ã‚²ã‚¹ãƒˆã® QR:</div>
    <canvas id="qrcodeGuest"></canvas>
  </div>

  <div class="box">
    <div class="role-label">â‘¢ ãƒãƒ£ãƒƒãƒˆ</div>
    <div id="status">çŠ¶æ…‹: æœªæ¥ç¶š</div>
    <div id="chatLog"></div>
    <input id="msg" type="text" placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸" disabled>
    <button id="send" disabled>é€ä¿¡</button>
  </div>

  <script>
    // --- WebRTC åŸºæœ¬ ---
    const pc = new RTCPeerConnection({
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    });
    let dataChannel = null;
    let localCandidates = [];
    let role = null; // "host" or "guest"

    const passwordInput = document.getElementById("password");
    const statusEl = document.getElementById("status");
    const chatLog = document.getElementById("chatLog");
    const msgInput = document.getElementById("msg");
    const sendBtn = document.getElementById("send");
    const qrcodeHostCanvas = document.getElementById("qrcodeHost");
    const qrcodeGuestCanvas = document.getElementById("qrcodeGuest");

    function logChat(text) {
      const time = new Date().toLocaleTimeString();
      chatLog.innerHTML += `[${time}] ${text}<br>`;
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    function setStatus(text) {
      statusEl.textContent = "çŠ¶æ…‹: " + text;
    }

    // --- æš—å·åŒ– / å¾©å·ï¼ˆAES-GCM + PBKDF2ï¼‰ ---
    async function deriveKey(password) {
      const enc = new TextEncoder().encode(password);
      const baseKey = await crypto.subtle.importKey("raw", enc, "PBKDF2", false, ["deriveKey"]);
      return crypto.subtle.deriveKey(
        { name: "PBKDF2", salt: new Uint8Array(16), iterations: 100000, hash: "SHA-256" },
        baseKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );
    }

    async function encryptJSON(obj, password) {
      const key = await deriveKey(password);
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const data = new TextEncoder().encode(JSON.stringify(obj));
      const enc = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, data);
      return btoa(JSON.stringify({
        iv: Array.from(iv),
        data: Array.from(new Uint8Array(enc))
      }));
    }

    async function decryptJSON(encText, password) {
      const key = await deriveKey(password);
      const obj = JSON.parse(atob(encText));
      const iv = new Uint8Array(obj.iv);
      const data = new Uint8Array(obj.data);
      const dec = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, data);
      return JSON.parse(new TextDecoder().decode(dec));
    }

    // ICEå€™è£œåé›†
    pc.onicecandidate = (e) => {
      if (e.candidate) {
        localCandidates.push(e.candidate);
      } else {
        console.log("ICE åé›†å®Œäº†");
      }
    };

    pc.oniceconnectionstatechange = () => {
      console.log("ICE state:", pc.iceConnectionState);
      if (pc.iceConnectionState === "connected") {
        setStatus("æ¥ç¶šå®Œäº†");
        msgInput.disabled = false;
        sendBtn.disabled = false;
        logChat("æ¥ç¶šã—ã¾ã—ãŸã€‚ãƒãƒ£ãƒƒãƒˆã§ãã¾ã™ã€‚");
      }
    };

    // DataChannel å—ä¿¡ï¼ˆã‚²ã‚¹ãƒˆå´ï¼‰
    pc.ondatachannel = (e) => {
      dataChannel = e.channel;
      setupDataChannel();
    };

    function setupDataChannel() {
      dataChannel.onopen = () => {
        setStatus("ãƒ‡ãƒ¼ã‚¿ãƒãƒ£ãƒãƒ«OPEN");
        msgInput.disabled = false;
        sendBtn.disabled = false;
      };
      dataChannel.onmessage = (e) => {
        logChat("ç›¸æ‰‹: " + e.data);
      };
      dataChannel.onclose = () => {
        setStatus("åˆ‡æ–­ã•ã‚Œã¾ã—ãŸ");
        msgInput.disabled = true;
        sendBtn.disabled = true;
      };
    }

    sendBtn.onclick = () => {
      const text = msgInput.value;
      if (!text || !dataChannel || dataChannel.readyState !== "open") return;
      dataChannel.send(text);
      logChat("è‡ªåˆ†: " + text);
      msgInput.value = "";
    };

    msgInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") sendBtn.click();
    });

    // --- ãƒ›ã‚¹ãƒˆã®å‡¦ç† ---
    document.getElementById("hostBtn").onclick = async () => {
      if (!passwordInput.value) {
        alert("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
        return;
      }
      role = "host";
      setStatus("ãƒ›ã‚¹ãƒˆ: Offer ä½œæˆä¸­â€¦");

      dataChannel = pc.createDataChannel("chat");
      setupDataChannel();

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      // å°‘ã—å¾…ã£ã¦ICEå€™è£œã‚’é›†ã‚ã¦ã‹ã‚‰ QR ä½œæˆ
      setTimeout(async () => {
        const signalData = {
          type: "offer",
          sdp: pc.localDescription,
          candidates: localCandidates
        };
        const enc = await encryptJSON(signalData, passwordInput.value);
        QRCode.toCanvas(qrcodeHostCanvas, enc, { width: 200 }, (err) => {
          if (err) console.error(err);
        });
        setStatus("ãƒ›ã‚¹ãƒˆ: QR ã‚’ã‚²ã‚¹ãƒˆã«èª­ã¿å–ã£ã¦ã‚‚ã‚‰ã£ã¦ãã ã•ã„");
        startHostScanner(); // ã‚²ã‚¹ãƒˆã‹ã‚‰ã® Answer ã‚’èª­ã‚€æº–å‚™
      }, 1500);
    };

    function startHostScanner() {
      const hostReaderElem = document.getElementById("readerHost");
      hostReaderElem.innerHTML = "";
      const html5QrCode = new Html5Qrcode("readerHost");
      html5QrCode.start(
        { facingMode: "environment" },
        { fps: 10, qrbox: 200 },
        async (decodedText) => {
          try {
            const data = await decryptJSON(decodedText, passwordInput.value);
            if (data.type === "answer") {
              await pc.setRemoteDescription(data.sdp);
              for (const c of data.candidates || []) {
                await pc.addIceCandidate(c);
              }
              setStatus("ãƒ›ã‚¹ãƒˆ: Answer ã‚’å—ä¿¡ã—ã¾ã—ãŸã€‚æ¥ç¶šå¾…ã¡â€¦");
              html5QrCode.stop().catch(console.error);
            }
          } catch (e) {
            console.error(e);
            alert("å¾©å·ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒä¸€è‡´ã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚");
          }
        },
        (err) => {
          // èª­ã¿å–ã‚Šå¤±æ•—æ™‚ã®ãƒ­ã‚°ï¼ˆç„¡è¦–ã—ã¦OKï¼‰
        }
      ).catch((err) => {
        console.error("QR ã‚¹ã‚­ãƒ£ãƒ³é–‹å§‹ã‚¨ãƒ©ãƒ¼:", err);
      });
    }

    // --- ã‚²ã‚¹ãƒˆã®å‡¦ç† ---
    document.getElementById("guestBtn").onclick = () => {
      if (!passwordInput.value) {
        alert("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
        return;
      }
      role = "guest";
      setStatus("ã‚²ã‚¹ãƒˆ: ãƒ›ã‚¹ãƒˆã® QR ã‚’èª­ã¿å–ã£ã¦ãã ã•ã„");
    };

    document.getElementById("startScanGuest").onclick = () => {
      if (role !== "guest") {
        alert("å…ˆã«ã€Œã‚²ã‚¹ãƒˆã¨ã—ã¦å‚åŠ ã™ã‚‹ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„");
        return;
      }
      const readerElem = document.getElementById("reader");
      readerElem.innerHTML = "";
      const html5QrCode = new Html5Qrcode("reader");
      html5QrCode.start(
        { facingMode: "environment" },
        { fps: 10, qrbox: 200 },
        async (decodedText) => {
          try {
            const data = await decryptJSON(decodedText, passwordInput.value);
            if (data.type === "offer") {
              setStatus("ã‚²ã‚¹ãƒˆ: Offer å—ä¿¡ã€‚Answer ä½œæˆä¸­â€¦");
              await pc.setRemoteDescription(data.sdp);
              for (const c of data.candidates || []) {
                await pc.addIceCandidate(c);
              }
              const answer = await pc.createAnswer();
              await pc.setLocalDescription(answer);
              setTimeout(async () => {
                const signalAnswer = {
                  type: "answer",
                  sdp: pc.localDescription,
                  candidates: localCandidates
                };
                const encAns = await encryptJSON(signalAnswer, passwordInput.value);
                QRCode.toCanvas(qrcodeGuestCanvas, encAns, { width: 200 }, (err) => {
                  if (err) console.error(err);
                });
                setStatus("ã‚²ã‚¹ãƒˆ: ã“ã® QR ã‚’ãƒ›ã‚¹ãƒˆã«èª­ã¿å–ã£ã¦ã‚‚ã‚‰ã£ã¦ãã ã•ã„");
                html5QrCode.stop().catch(console.error);
              }, 1500);
            }
          } catch (e) {
            console.error(e);
            alert("å¾©å·ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒä¸€è‡´ã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚");
          }
        },
        (err) => {
          // èª­ã¿å–ã‚Šå¤±æ•—æ™‚ã¯ç„¡è¦–
        }
      ).catch((err) => {
        console.error("QR ã‚¹ã‚­ãƒ£ãƒ³é–‹å§‹ã‚¨ãƒ©ãƒ¼:", err);
      });
    };
  </script>
</body>
</html>
